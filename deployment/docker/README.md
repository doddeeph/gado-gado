# Docker
Docker is a platform for developing, shipping, and running applications in containers. Containers are lightweight, portable, and self-sufficient units that can run applications and their dependencies in isolated environments. Docker provides a set of tools and a platform to simplify the process of creating, deploying, and managing containerized applications.

## Here are some key concepts related to Docker:
1. **Container**: A container is a standalone, executable package that includes everything needed to run a piece of software, including the code, runtime, libraries, and system tools. Containers are isolated from each other and from the host system, making them portable and consistent across different environments.
2. **Docker Engine**: The Docker Engine is the core component of Docker. It is responsible for building, running, and managing containers. The Docker Engine includes a server process, a REST API, and a command-line interface.
3. **Docker Image**: A Docker image is a lightweight, standalone, and executable package that includes everything needed to run a piece of software, including the code, runtime, libraries, and system tools. Images are used to create containers.
4. **Dockerfile**: A Dockerfile is a script that contains instructions for building a Docker image. It specifies the base image, sets up the environment, installs dependencies, and configures the application.
5. **Docker Hub**: Docker Hub is a cloud-based registry service that allows users to share and distribute Docker images. It provides a centralized repository for Docker images, and users can pull and push images to and from Docker Hub.
6. **Container Orchestration**: Docker can be used in conjunction with container orchestration tools like Kubernetes and Docker Swarm to manage the deployment, scaling, and orchestration of containers in a clustered environment.
7. **Docker Compose**: Docker Compose is a tool for defining and running multi-container Docker applications. It allows you to define a multi-container environment in a single file and then use that file to create and manage the entire application stack.

Docker is widely used in software development and deployment processes as it simplifies the management of dependencies, ensures consistency across different environments, and facilitates the deployment of applications in a scalable and reproducible manner.

## Let's create a simple example of a Dockerized Spring Boot application. We'll create a basic Spring Boot application with a REST endpoint, and then we'll create a Dockerfile to containerize it.
1. Create a Spring Boot Application:
Start by creating a simple Spring Boot application. Create a file named DemoApplication.java with the following content:
```
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}

@RestController
class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "Hello, Docker with Spring Boot!";
    }
}
```

2. Create a Dockerfile:
Create a file named `Dockerfile` in the same directory as your `DemoApplication.java`:
```
# Use an official OpenJDK runtime as a base image
FROM openjdk:11

# Set the working directory in the container
WORKDIR /app

# Copy the JAR file into the container at /app
COPY target/demo-0.0.1-SNAPSHOT.jar /app/demo.jar

# Expose port 8080 to the outside world
EXPOSE 8080

# Define the command to run your application
CMD ["java", "-jar", "demo.jar"]
```
This Dockerfile does the following:
- Specifies OpenJDK version 11 as the base image.
- Sets the working directory in the container.
- Copies the JAR file generated by the Spring Boot build to the container.
- Exposes port 8080.
- Defines the command to run the Spring Boot application.

3. Build the Spring Boot Application:
Build the Spring Boot application by running the following command in the terminal:
```
mvn package
```
This command build the project and generate a JAR file.

4. Build the Docker Image:
Now, build the Docker image with the following command:
```
docker build -t my-spring-boot-app .
```
This command builds a Docker image with the tag `my-spring-boot-app`.

5. Run the Docker Container:
Run a container based on the built image:
```
docker run -p 8080:8080 my-spring-boot-app\
```
This command maps port 8080 from the container to port 8080 on your host machine.

6. Access the REST Endpoint:
Open your web browser or use a tool like curl to access the REST endpoint:
```
curl http://localhost:8080/hello
```
You should see the response `"Hello, Docker with Spring Boot!"`

## Difference between COPY and ADD
In a `Dockerfile`, both COPY and ADD instructions are used to copy files/directories into the Docker image, but they have some important differences.

### ‚úÖ COPY (Preferred for simple copying)
- Purpose: Only copies files or directories from the source to the destination in the container.
- Syntax:
    ```
    COPY <source> <destination>
    ```
- Example:
    ```
    COPY app.jar /app/app.jar
    ```

### ‚úÖ ADD (COPY + Extras)
- Purpose: Copies files like COPY, but also:
  1. Automatically extracts local tar archives (.tar, .tar.gz, etc.)
  2. Supports remote URLs (downloads files from the internet)
- Syntax:
    ```
    ADD <source> <destination>
    ```
- Examples:
    ```
    # Copying and extracting a tar file
    ADD archive.tar.gz /app/
    
    # Downloading a file from a URL
    ADD https://example.com/file.txt /app/file.txt
    ```

### ‚ö†Ô∏è Summary of Differences
| Feature                | `COPY`        | `ADD`                            |
| ---------------------- | ------------- | -------------------------------- |
| Copy local files       | ‚úÖ             | ‚úÖ                                |
| Extract `.tar.gz`, etc | ‚ùå             | ‚úÖ                                |
| Supports URLs          | ‚ùå             | ‚úÖ                                |
| Simpler & predictable  | ‚úÖ (preferred) | ‚ùå (can have unexpected behavior) |

### üîß Best Practice
Use `COPY` unless you specifically need the extra features of `ADD`.
This improves readability and avoids unintentional behavior (like automatic tar extraction or unwanted internet downloads).

## Difference between CMD and ENTRYPOINT
### üîß CMD vs ENTRYPOINT ‚Äì Core Differences
| Feature                    | `CMD`                                        | `ENTRYPOINT`                                         |
| -------------------------- | -------------------------------------------- | ---------------------------------------------------- |
| Purpose                    | Sets **default arguments** for the container | Sets the **main command** to run                     |
| Overridable with arguments | ‚úÖ Yes                                        | ‚úÖ Yes (only if used with `ENTRYPOINT` + `CMD`)       |
| Common use case            | Default command that users can override      | Always runs, useful for wrapping the container logic |
| Can be ignored/replaced    | ‚úÖ Yes, if args are provided to `docker run`  | ‚ùå Not ignored, unless overridden with `--entrypoint` |
| Format                     | Shell or exec format                         | Shell or exec format                                 |

### ‚úÖ Examples
Example 1: Using CMD
```
FROM alpine
CMD ["echo", "Hello from CMD"]
```
```
docker build -t cmd-example .
docker run cmd-example             # Output: Hello from CMD
docker run cmd-example echo Bye   # Output: Bye
```
The second run overrides the `CMD`.

Example 2: Using ENTRYPOINT
```
FROM alpine
ENTRYPOINT ["echo"]
```
```
docker build -t entrypoint-example .
docker run entrypoint-example Hello   # Output: Hello
docker run entrypoint-example Bye     # Output: Bye
```
`ENTRYPOINT` can‚Äôt be overridden unless you use `--entrypoint`.

Example 3: Combine ENTRYPOINT and CMD
```
FROM alpine
ENTRYPOINT ["echo"]
CMD ["Hello from CMD"]
```
```
docker build -t combined-example .
docker run combined-example             # Output: Hello from CMD
docker run combined-example Bye         # Output: Bye
```
In this case:
- `ENTRYPOINT` runs `echo`
- `CMD` provides the default argument (`Hello from CMD`)
- You can override `CMD`, but not `ENTRYPOINT`

### üèÅ Summary
| Scenario                                                           | Use `CMD`               | Use `ENTRYPOINT` |
| ------------------------------------------------------------------ | ----------------------- | ---------------- |
| You want a **default** command that can be overridden              | ‚úÖ                       |                  |
| You want a **fixed** command to always run (like a script wrapper) |                         | ‚úÖ                |
| You want both fixed and flexible behavior                          | ‚úÖ with ENTRYPOINT + CMD |                  |

### üõ†Ô∏è Best Practice
For most Spring Boot apps:
```
ENTRYPOINT ["java", "-jar", "app.jar"]
```
Or:
```
ENTRYPOINT ["java", "-jar"]
CMD ["app.jar"]
```
This allows overriding the jar or passing extra JVM args.

# Docker Compose
Docker Compose is a tool for defining and running multi-container Docker applications. It allows you to define an entire application stack, including services, networks, and volumes, in a single YAML file. With Docker Compose, you can start and manage multiple containers as a single application, making it easier to set up and deploy complex applications with multiple components.

Here's an example of using Docker Compose with a Spring Boot application:
1. Create a Spring Boot Application:
Use the same Spring Boot application example as before. Ensure you have the `DemoApplication.java` and `Dockerfile` files in your project.

2. Create a Docker Compose File:
Create a file named `docker-compose.yml` in the same directory as your Spring Boot project with the following content:
```
version: '3'
services:
    spring-app:
        build:
            context: .
            dockerfile: Dockerfile
        ports:
            - "8080:8080"
        depends_on:
            - mongo
    mongo:
        image: mongo
        ports:
            - "27017:27017"
```

In this example, we define two services:
- `spring-app`: This service builds the Spring Boot application using the specified Dockerfile. It exposes port 8080 and depends on the `mongo` service.
- `mongo`: This service uses the official MongoDB image and exposes port 27017.

3. Build the Spring Boot Application:
If you haven't done so already, build the Spring Boot application using the Maven command:
```
mvn package
```

4. Build and Run with Docker Compose:
Use the following commands to build and run the application stack with Docker Compose:
```
docker-compose up --build
```
The `--build` flag ensures that Docker Compose builds the images before starting the containers.

5. Access the REST Endpoint:
Once the containers are running, you can access the Spring Boot application's REST endpoint as before:
```
curl http://localhost:8080/hello
```
The application now interacts with a MongoDB instance running in a separate container.

6. Stop the Containers:
To stop the running containers, press `Ctrl+C` in the terminal where Docker Compose is running, or run:
```
docker-compose down
```

This example demonstrates how Docker Compose can be used to define a multi-container environment for a Spring Boot application along with a MongoDB service. It simplifies the management of the entire application stack, making it easy to start, stop, and scale your services. Adjust the docker-compose.yml file according to your specific requirements and dependencies.
